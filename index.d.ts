// Generated by dts-bundle v0.5.0
// Dependencies for this module:
//   ../carbyne

declare module 'carbyne-leaflet' {
    export { MapCtrl } from 'carbyne-leaflet/map';
    export { MarkerStore } from 'carbyne-leaflet/marker-store';
    export { createCarbyneIcon } from 'carbyne-leaflet/carbyne-marker';
}

declare module 'carbyne-leaflet/map' {
    import { Controller } from 'carbyne';
    import 'leaflet';
    export var TILE_LAYER: string;
    /**
        * Additions to the leaflet typings for some undocumented methods.
        */
    global  {
            namespace L {
                    /**
                        * Give the layer id of any layer. Useful with
                        * featureGroup (not in the original typings)
                        */
                    function stamp(layer: ILayer): number;
            }
    }
    /**
        * Un type d'icone custom qui prend du carbyne pour faire son marker.
        * Nota : c'est peut être pas trop ce qu'on veut faire (après tout, il n'y
        * a peut être pas grand chose de dynamique dans ce qu'on veut mettre
        * dans une icône)
        */
    export type MapReadyFn = (map: L.Map) => any;
    /**
        * Le contrôle appelé par tous les états/controlleurs qui souhaitent afficher des
        * informations.
        */
    export class MapCtrl extends Controller {
            onMount(): void;
            run(fn: MapReadyFn): void;
            onDestroy(): void;
    }
}

declare module 'carbyne-leaflet/marker-store' {
    import { Atom, ArrayObservable, Observable, Appendable } from 'carbyne';
    /**
        * Constructeur de Popup qui attend à la fois un observable de liste
        * et un item. Doit faire un item.set() d'un élément de sa liste pour être
        * plus logique.
        */
    export type PopupFn<T> = (list: Observable<T[]>, item: Observable<T>) => Atom;
    export type MarkerFn<T> = (o: Observable<T[]>) => Appendable;
    export interface ILocatable {
            latlng(items?: ILocatable[]): L.LatLng;
    }
    export type MarkerAndObs<T> = {
            marker: L.Marker;
            obs: ArrayObservable<T>;
    };
    /**
        *
        */
    export class MarkerStore<T extends ILocatable> {
            ᐅselected: Observable<T>;
            protected map: L.Map;
            protected layer: L.FeatureGroup<L.Marker>;
            protected popup: Atom;
            protected markerfn: MarkerFn<T>;
            protected llmap: Map<string, MarkerAndObs<T>>;
            protected itemmap: Map<T, L.Marker>;
            protected ᐅselected_list: Observable<T[]>;
            constructor(popup: PopupFn<T>, marker_fn: MarkerFn<T>);
            setMap(map: L.Map): void;
            /**
                * Sélectionne un target, centre la map et fait apparaître le popup le concernant.
                * Nota : ceci ignore donc forcément le fait qu'il peut y avoir d'autres objets au
                * même endroit.
                */
            selectItem(item: T): void;
            /**
                * Sélectionne un marqueur. Aboutit à l'affichage du popup en mode
                * liste ou single dépendamment du nombre de points enregistrés sur cette
                * même position.
                */
            selectMarker(marker: L.Marker): void;
            closePopup(): void;
            /**
                * Mise à jour des marqueurs présents sur la map.
                *
                * 1. Groupement des marqueurs par latitude et longitude.
                * 2. Récupération des marqueurs existants pour savoir ceux qu'on peut réutiliser.
                * 		/!\ certains marqueurs peuvent devenir multiples et doivent donc être supprimés (?)
                * 3. Création des marqueurs manquants
                * 4. Suppression des marqueurs superflus
                */
            updateItems(items: T[]): void;
            fitBounds(): void;
            /**
                * Ne sélectionne pas un target, mais potentiellement une liste de ceux-ci
                */
            handleClick(event: L.LeafletMouseEvent): void;
            /**
                * Nettoyage du popup pour éviter les memory leaks et suppression
                */
            destroy(): void;
    }
}

declare module 'carbyne-leaflet/carbyne-marker' {
    import { Atom, Appendable } from 'carbyne';
    /**
        * Extension de leaflet pour signaler qu'on a créé un nouveau type d'icône.
        */
    global  {
            namespace L {
                    interface CarbyneIconOptions extends IconOptions {
                            marker: () => Atom;
                    }
                    interface CarbyneIcon extends Icon {
                    }
                    interface CarbyneIconStatic extends ClassStatic {
                            new (options: CarbyneIconOptions): CarbyneIcon;
                    }
                    var CarbyneIcon: CarbyneIconStatic;
                    var carbyneIcon: (options: CarbyneIconOptions) => CarbyneIcon;
                    interface CarbyneMarker extends Marker {
                    }
                    interface CarbyneMarkerStatic extends ClassStatic {
                            new (ll: LatLngExpression, options?: MarkerOptions): CarbyneMarker;
                    }
                    var CarbyneMarker: CarbyneMarkerStatic;
                    var carbyneMarker: (ll: LatLngExpression, options?: MarkerOptions) => CarbyneMarker;
            }
    }
    /**
        *
        */
    export function createCarbyneIcon(cnts: Appendable, opts?: any): L.CarbyneIcon;
}

